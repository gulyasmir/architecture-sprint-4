# Задание 5. Кеширование

Чтобы улучшить производительность и сократить задержки в обработке данных, рекомендуется внедрение **кеширования** для наиболее нагруженных элементов системы.

## ** Мотивация**

### **Проблемы, которые нужно решить**

1. **Медленная загрузка страниц в MES**
   * Операторы сталкиваются с долгим откликом интерфейса, особенно при загрузке списка заказов и их статусов.
   * Высокая нагрузка на базу данных MES, так как каждый операторский запрос выполняет сложные вычисления.
2. **Замедление выполнения заказов**
   * Долгая обработка заказов, особенно при распределении их между операторами.
   * Частые обращения к **MES API** и **MES DB** создают дополнительную нагрузку на сервер, увеличивая время ответа.
3. **Высокая нагрузка на базу данных MES**
   * Частые и повторяющиеся запросы к **MES DB**, которые загружают сервер и приводят к задержкам в обработке запросов.

### **Решение: Внедрение кеширования**

Кеширование позволит **уменьшить количество обращений к базе данных** и **ускорить работу API**, сохраняя предварительно загруженные или вычисленные данные в быстром хранилище (Redis, in-memory кеши, CDN и т. д.).

## Предлагаемое решение

### **Выбор типа кеширования: клиентское или серверное?**

Для оптимизации работы **MES** мы выбираем **серверное кеширование**, а не клиентское.

#### **Почему именно серверное кеширование?**

**Основная проблема — высокая нагрузка на сервер MES API и базу данных.**

* Серверное кеширование **разгрузит базу данных** и ускорит обработку запросов.
* Клиентское кеширование может помочь только с фронтендом, но не решит проблему долгих запросов к API.

*Клиентское кеширование в браузере имеет ограничения.**

* Статические файлы (JS, CSS) уже могут кешироваться браузером и CDN.
* Но **основная задержка** возникает из-за запросов на сервер (например, получение списка заказов), которые нельзя эффективно кешировать на клиенте.

**Операторы работают с динамическими данными.**

* Клиенты и операторы могут менять заказы в реальном времени.
* Клиентский кеш **может устаревать** и приводить к отображению неправильных данных.

Вывод:  Клиентский кеш можно использовать только для статических ресурсов (изображения, CSS, JS), но **основное кеширование должно быть серверным**.

### **Выбор паттерна серверного кеширования**

Для каждого типа данных выберем **наиболее подходящий паттерн кеширования**, чтобы максимизировать производительность и обеспечить актуальность данных.

#### **Паттерн Cache-Aside (ленивое кеширование) — основной выбор**

**Применять для:**

* **Список заказов (Orders List)**
* **Статусы заказов**
* **Детальная информация о заказе**
* **Результаты расчёта стоимости заказа**

**Как работает:**

* Когда клиент запрашивает данные, сначала проверяем **кеш (Redis)**.
* Если данные **есть в кеше** — возвращаем их.
* Если данных **нет в кеше** — делаем запрос в **базу данных (PostgreSQL)**, сохраняем результат в **Redis** и возвращаем пользователю.

Этот паттерн орошо работает, если данные **изменяются нечасто**. Он не перегружает кеш, сохраняет только те данные, которые действительно востребованы. Так же гибкость — можно настроить разное время жизни кеша (TTL) для разных типов данных.

Почему не Write-Through?

* **Write-Through медленнее**, так как при каждом изменении сразу обновляет кеш (в нашем случае заказы обновляются не так часто, это лишняя нагрузка).
* Не подходит для редко используемых данных (заполняет кеш данными, которые могут никогда не понадобиться).

Почему не Refresh-Ahead?

* **Прогнозировать, когда данные понадобятся операторам, сложно.**
* Этот паттерн лучше подходит для **предсказуемых нагрузок** (например, данные, которые точно запрашиваются каждые X секунд).

#### **Паттерн Write-Through — для кеширования предварительных расчётов**

Применять для кеширование рассчитанной стоимости заказов** (например, при выборе параметров заказа).

Когда данные записываются в базу **(например, изменяется стоимость заказа)**, они **сразу** записываются и в кеш. Чтение всегда идёт **из кеша**, а не из базы.

Этот паттерн подходит для данных, которые **часто читаются, но редко изменяются**.  **Гарантирует актуальность кеша** (так как данные обновляются синхронно с базой).

Почему не Cache-Aside?

* В Cache-Aside кеш обновляется **только при запросе**, что может привести к ситуации, когда оператор получает **устаревшую стоимость заказа**.
* Write-Through **лучше** для важной информации, которая должна быть **всегда актуальной**.

#### Распределение паттернов кеширования


| **Что кешируем?**                                            | **Тип кеширования** | **Выбранный паттерн** | **Обоснование**                                                                      |
| ----------------------------------------------------------------------- | --------------------------------- | ------------------------------------- | ----------------------------------------------------------------------------------------------- |
| **Список заказов (Orders List)**                           | Серверный (Redis)        | **Cache-Aside**                       | Часто запрашиваемые, но не часто обновляемые данные |
| **Статусы заказов**                                       | Серверный (Redis)        | **Cache-Aside**                       | Часто читаются, но обновляются только при изменении |
| **Детальная информация о заказе**             | Серверный (Redis)        | **Cache-Aside**                       | Уменьшает нагрузку на базу данных                                  |
| **Рассчитанная стоимость заказа**            | Серверный (Redis)        | **Write-Through**                     | Должна быть всегда актуальной, но редко изменяется   |
| **Статические файлы (JS, CSS, изображения)** | Клиентский (CDN)        | HTTP-кеш браузера          | Ускоряет загрузку интерфейса                                          |

Я считаю, что это решение будет эффективным, т.к. даст

1. Снижение нагрузки на БД - примерно на 40-50% меньше запросов.
2. Ускорение API (MES API, Shop API) ответы будут быстрее на 60-80%
3. Операторы получит моментальный доступ а списку заказов и их статусам.
4. Автоматическая очистка кеша **(TTL)** не даст использовать устаревшие данные.


**Диаграмма находится в файле  diagram.puml**

#### Описание диаграммы:

* **Чтение списка заказов**
  * Оператор запрашивает список заказов у **MES API**.
  * **MES API** проверяет кеш (**Redis Cache**).
  * Если кеш найден, он сразу возвращается.
  * Если кеш **отсутствует (cache miss)**:
    * **MES API** запрашивает список заказов из **базы данных**.
    * Ответ сохраняется в кеше для будущих запросов.
  * Оператор получает список заказов.
* **Обновление статуса заказа**
  * Оператор отправляет запрос на **изменение статуса** заказа.
  * **MES API** обновляет данные в **базе данных**.
  * Подтверждает операцию.
  * **MES API** инвалидирует кеш, чтобы в следующий раз информация была актуальной.
  * Оператор получает подтверждение.


### **Стратегия инвалидации кеша для MES**

*Инвалидация кеша* — это процесс удаления устаревших данных из кеша, чтобы пользователи всегда получали актуальную информацию. Для **MES-системы**, где операторы работают со списками заказов, важно выбрать стратегию, которая **обеспечит баланс между производительностью и актуальностью данных**.

***Выбранная стратегия*: Инвалидация по ключу (Key-Based Invalidation)**

Я считаю, что лучше всего применять **инвалидацию кеша по ключу**, когда обновляется статус заказа. Это означает, что при **изменении информации в базе данных, соответствующий кеш будет немедленно удаляться**. 

**Почему  именно инвалидация по ключу:**

- **Гарантированная актуальность** – при каждом изменении статуса кеш удаляется, и следующий запрос получит свежие данные из базы.
- **Гибкость** – можно удалять кеш только для определённого заказа, не затрагивая другие данные.
- **Хорошо работает с Redis** – большинство кеширующих решений поддерживают этот механизм.

**Другие возможные стратегии и их анализ**


| **Стратегия**                  | **Инвалидация по ключу (выбранная)**                                                                                                                             | **Временная инвалидация (TTL)**                                                                                                                                                                                                                  | **Программная инвалидация (Refresh-Ahead)**                                                                                                                                                                                                                                                       |
| --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Как работает?**            | Кеш удаляется, когда данные в БД обновляются.                                                                                                          | Данные хранятся в кеше**до определенного времени (TTL)**, затем автоматически удаляются.                                                                                                         | Система сама обновляет кеш в фоне перед его устареванием.                                                                                                                                                                                                               |
| **Достоинства**              | 🔹 Позволяет всегда получать актуальные данные.<br/>🔹 Гибкое управление кешем.<br/>🔹 Хорошо работает в Redis. | 🔹 Уменьшает нагрузку на БД, так как кеш живёт долго.<br/>🔹 Хорош для редко изменяющихся данных.                                                                                             | 🔹 Позволяет минимизировать задержки, так как обновляет кеш заранее.<br/>🔹 Работает без участия пользователя.                                                                                                                    |
| **Недостатки**                | Требует явного удаления кеша, что увеличивает сложность кода.                                                                           | ❌ Есть риск, что данные устареют до истечения TTL.<br/>❌ Если TTL короткий – будет много кеш-миссов, если длинный – данные могут устареть.                      | ❌ Усложняет архитектуру, так как требует дополнительных механизмов для предзагрузки данных.<br/>❌ Может загружать неактуальные данные.                                                                  |
| **Почему не подходит?** | Самый точный метод для нашей задачи, так как MES требует свежих данных.                                                              | ❌ Нельзя гарантировать, что данные будут обновляться сразу после изменения.<br/>❌ MES требует**оперативных обновлений**, а TTL может их задерживать. | ❌ Операции в MES зависят от действий пользователя, а**Refresh-Ahead не всегда предугадает**нужные данные.<br/>❌ Может загружать ненужную информацию, увеличивая нагрузку на систему. |

#### **Вывод**

🔹 **Инвалидация по ключу (Key-Based Invalidation) – лучший вариант** для MES, так как она **гарантирует актуальные данные при изменении статуса заказа**.
🔹 **Временная (TTL) инвалидация** подходит, если заказы редко обновляются, но в нашем случае данные меняются динамично.
🔹 **Программная (Refresh-Ahead) инвалидация** слишком сложна и может не угадывать, какие данные обновить заранее.

Таким образом, **инвалидация по ключу позволит MES работать быстрее, снизит нагрузку на базу данных и обеспечит актуальность заказов**.
